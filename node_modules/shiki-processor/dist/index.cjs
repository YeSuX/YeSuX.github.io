'use strict';

const shiki = require('shiki');

function createRangeProcessor(dictionary, options = {}) {
  return ({ code }) => {
    const tagRE = options.tagRegExp ?? /(?:\/\/|\/\*{1,2}) *\[!code ([\w+-]+)(?::(\d+))?] *(?:\*{1,2}\/)?/;
    const lineOptions = [];
    code = code.split("\n").map((lineOfCode, lineNumber) => {
      const [match, tag, range] = lineOfCode.match(tagRE) ?? [];
      if (!match) {
        return lineOfCode;
      }
      if (!Object.keys(dictionary).includes(tag)) {
        return lineOfCode;
      }
      Array.from({ length: Number(range ?? 1) }).forEach((_, rangeOffset) => {
        lineOptions.push({
          line: lineNumber + rangeOffset + 1,
          classes: dictionary[tag]
        });
      });
      return lineOfCode.replace(tagRE, "");
    }).join("\n");
    return {
      code,
      lineOptions
    };
  };
}

function addClass(code, classes, tag) {
  const classRE = new RegExp(`<${tag ?? "w+"}[^>]*class="([\\w+-:;\\/* ]*)"`);
  classes = !Array.isArray(classes) ? [classes] : classes;
  return code.replace(classRE, (match, previousClasses) => {
    return match.replace(previousClasses, `${previousClasses} ${classes}`);
  });
}

function createDiffProcessor(options = {}) {
  const commonDiffClass = options.commonDiffClass ?? "diff";
  const removedLinesClasses = options.removedLinesClasses ?? ["remove"];
  const addedLinesClasses = options.removedLinesClasses ?? ["add"];
  const removeLineTag = options.removeLineTag ?? "--";
  const addLineTag = options.addLineTag ?? "++";
  const hasDiffClass = options.hasDiffClass ?? "has-diff";
  return {
    name: "diff",
    handler: createRangeProcessor({
      [removeLineTag]: [commonDiffClass, ...removedLinesClasses],
      [addLineTag]: [commonDiffClass, ...addedLinesClasses]
    }, options),
    postProcess: ({ code }) => {
      if (!code.includes(commonDiffClass)) {
        return code;
      }
      return addClass(code, hasDiffClass, "pre");
    }
  };
}

function createFocusProcessor(options = {}) {
  const hasFocusClass = options.hasFocusClass ?? "has-focus";
  const hasFocusedLinesClass = options.hasFocusedLinesClass ?? "has-focused-lines";
  const focusTag = options.focusTag ?? "focus";
  return {
    name: "focus",
    handler: createRangeProcessor({
      [focusTag]: [hasFocusClass]
    }, options),
    postProcess: ({ code }) => {
      if (!code.includes(hasFocusClass)) {
        return code;
      }
      return addClass(code, hasFocusedLinesClass, "pre");
    }
  };
}

function createHighlightProcessor(options = {}) {
  const hasHighlightClass = options.hasHighlightClass ?? "has-highlight";
  const hasHighlightedLinesClass = options.hasHighlightedLinesClass ?? "has-highlighted-lines";
  const highlightTag = options.highlightTag ?? "hl";
  return {
    name: "highlight",
    handler: createRangeProcessor({
      [highlightTag]: [hasHighlightClass]
    }, options),
    postProcess: ({ code }) => {
      if (!code.includes(hasHighlightClass)) {
        return code;
      }
      return addClass(code, hasHighlightedLinesClass, "pre");
    }
  };
}

function defineProcessor(processor) {
  return processor;
}
function process(processors, code, lang) {
  return processors.reduce((options, processor) => {
    const { code: code2, lineOptions } = processor.handler?.({
      code: options.code,
      lang
    }) ?? options;
    return {
      code: code2,
      lineOptions: [
        ...options.lineOptions,
        ...lineOptions
      ]
    };
  }, {
    code,
    lineOptions: []
  });
}
function postProcess(processors, code, lang) {
  return processors.reduce((code2, processor) => processor.postProcess?.({
    code: code2,
    lang
  }) ?? code2, code);
}

async function getHighlighter(options = {}) {
  const highlighter = await shiki.getHighlighter(options);
  const processors = options.processors ?? [];
  return {
    ...highlighter,
    codeToHtml: (str, htmlOptions) => {
      const lang = typeof htmlOptions === "object" ? htmlOptions.lang : htmlOptions;
      const baseLineOptions = typeof htmlOptions === "object" ? htmlOptions.lineOptions ?? [] : [];
      const theme = typeof htmlOptions === "object" ? htmlOptions.theme : void 0;
      const { code, lineOptions } = process(processors, str, lang);
      const highlighted = highlighter.codeToHtml(code, {
        lang,
        theme,
        lineOptions: [
          ...lineOptions,
          ...baseLineOptions
        ]
      });
      return postProcess(processors, highlighted, lang);
    }
  };
}

exports.addClass = addClass;
exports.createDiffProcessor = createDiffProcessor;
exports.createFocusProcessor = createFocusProcessor;
exports.createHighlightProcessor = createHighlightProcessor;
exports.createRangeProcessor = createRangeProcessor;
exports.defineProcessor = defineProcessor;
exports.getHighlighter = getHighlighter;
exports.postProcess = postProcess;
exports.process = process;
